package kr.bang.algorithm;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Jangi {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		Queue<Integer> queue = new LinkedList<Integer>();//큐 생성
		int N, M;
		N = s.nextInt();
		M = s.nextInt();
		boolean[][] check = new boolean[N+1][M+1];
		int current_x = s.nextInt();
		int current_y = s.nextInt();
		int current_count = 0;		
		int destination_x = s.nextInt();
		int destination_y = s.nextInt();
		queue.offer(current_x);
		queue.offer(current_y);
		queue.offer(current_count);
		int x, y, count;
		// 함수는 똑같이 동작하도록 만들어놓고 위치와 실행 횟수를 같이 저장하는 큐를 만들자.
		while(true) {
			x = queue.poll();
			y = queue.poll();
			count = queue.poll();
			for(int[] e : queue) {
				System.out.println("queue : ["+e[0]+","+e[1]+","+e[2]+"]");
			}
			System.out.printf("queue polled : [%d,%d,%d]\n",wait[0],wait[1],wait[2]);
			if(check[wait[0]][wait[1]]) continue;
			//System.out.printf("[%d, %d, %d]",wait[0],wait[1],wait[2]);
			if(wait[0]==destination[0] && wait[1]==destination[1]) {
				System.out.println(wait[2]);
				break;
			}
			int[] copy = new int[3];
			if(wait[0]-1>0 && wait[1]-2>0) {
				queue.offer(x);
				queue.offer(y);
				queue.offer(count);
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]-2>0 && wait[1]-1>0) {
				copy[0] = wait[0]-2;
				copy[1] = wait[1]-1;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]-2>0 && wait[1]+1<M+1) {
				copy[0] = wait[0]-2;
				copy[1] = wait[1]+1;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]-1>0 && wait[1]+2<M+1) {
				copy[0] = wait[0]-1;
				copy[1] = wait[1]+2;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]+1<N+1 && wait[1]+2<M+1) {
				copy[0] = wait[0]+1;
				copy[1] = wait[1]+2;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]+2<N+1 && wait[1]+1<M+1) {
				copy[0] = wait[0]+2;
				copy[1] = wait[1]+1;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]+2<N+1 && wait[1]-1>0) {
				copy[0] = wait[0]+2;
				copy[1] = wait[1]-1;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			if(wait[0]+1>0 && wait[1]-2>0) {
				copy[0] = wait[0]+1;
				copy[1] = wait[1]-2;
				copy[2] = wait[2]+1;
				System.out.printf("copy offered : [%d, %d, %d]\n",copy[0],copy[1],copy[2]);
				queue.offer(copy);
			}
			check[wait[0]][wait[1]] = true;
		}
		
	}
	
}
