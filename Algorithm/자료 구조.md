# 자료 구조

프로그램 서비스 구현, 문제 풀이 시 데이터를 담아서 유지 관리하기 위한 목적

ex - 친구의 연락처 저장 관리 한다 했을 때, 차례대로 저장하고 싶은 사람도 있고, 친구들의 이름만 알면 빠르게 찾을 수 있도록 하고 싶은사람이 있고, 최근에 저장한 순, 처음 순으로 관리하고 싶은 사람도 있을 것이다.

### 자료 구조 = 자료(데이터) + 자료에 대한 연산작업(추가, 수정, 삭제, 조회=CRUD) + 알고리즘(순차적으로 저장할건지, key값으로 저장할건지 - 이에 따라 자료의 구조가 달라진다.)

1. 선형 자료구조

   - 한 줄로 줄을 세울 수 있는 자료구조

     ㅁ-ㅁ-ㅁ-ㅁ

     자료들이 앞 뒤로 1:1 관계를 가지고 있다. 앞에도 하나, 뒤에도 하나만 있어야 한다.

     **순차 자료구조** - 순서를 부여할 수 있다.

     - 배열 : 동형집합(같은 집합) - 하나의 객체(여러개 요소가 알아서 공간을 나눠서 쓰고있음) - 크기고정(필요에 따라 아느 부분을 지울 수 없다.)

       - JAVA의 경우 타입과 사이즈를 선언해주면 그 안에 데이터를 저장할 수 있는 슬롯(방)과같은 개념
         1. 1차원 배열 - 데이터는 배열안에 들어감
         2. 2차원 배열(배열의 원소가 배열 - array of array) - 데이터는 서브 배열 안에 들어가고 배열에는 reference가 들어간다. 오프셋을 배열마다 따로 가지고있다.
       - 실제 속도는 가장 빠르다. 
         - 크기가 고정되어 있어서
         - 대신 가변적인 사이즈를 가져야 하는 경우(추가 or 삭제) 최대값으로 사이즈를 잡아야 하는 단점이 있다. (이를 위해서 Linked List를 사용한다)

     - 연결리스트(Linked List)

       - 배열을 하나하나씩 다 쪼개는 개념

       - 쪼개진 하나 하나를 모두 이어서 관리한다.

       - 장점 : 요소의 추가나 삭제가 가능하다. ex) 길이 4의 리스트 두번째에 삽입을 하고 싶을 경우 2번의 연산으로 가능하다. 모든 데이터를 뒤로 미루는 개념이 아니라 추가할 것의 앞의 연결을 다시 설정해주고, 추가한 것과 그 뒤에 연결을 다시 설정해준다.

         1. 단순 연결리스트

            ㅁ→ㅁ→ㅁ

            ㅁ : 노드, → : 링크 포인터(간단하게 한쪽으로만 이어지게 한다.)

            첫번째 노드만 알고있으면 연결된 노드들의 정보를 얻을 수 있다.

            마지막 노드는 링크 포인터가 없으므로 이에 대한 관리를 따로 해줘야 한다.

            중간의 노드의 이전 경로를 찾기 위해서 처음부터 순서대로 확인해보아야 한다.

         2. 이중 연결리스트

            링크 포인터가 양쪽으로 연결되어 있다.

         3. 원형 연결리스트(circular linked list)

            마지막 노드에서도 다음 노드 탐색을 쉽게 하고 싶어서 만듬

            단순 원형과 이중 원형이 있다.

     - 스택

       후입선출구조(LIFO, FILO)

       들어오는 방향, 나가는 방향이 한곳이다.

       데이터가 들어가는 과정 - push

       데이터가 나오는 과정 - top 원소를 제거하고 꺼냄 - pop 

       top 원소를 제거하지 않고 확인만(복사같은) - peek

       가장 위에 있는 데이터의 위치 - top

       브라우저의 뒤로가기, 앞으로가기에 스택 2개 사용

     - 큐

       선입선출구조(FIFO,LILO)

       들어오는 방향, 나가는 방향이 다르다.

       대기열 관리 - 순차적으로 먼저 들어온 사람 먼저 처리

       데이터가 들어가는 과정(삽입) - EnQueue

       데이터를 빼내는 과정(삭제) - DeQueue

       출구의 위치 - front

       입구의 위치 - rear

       rear로 들어와서 front로 나간다.

     - 덱

       큐와 스택의 특성을 혼합

       후입선출, 선입선출 모두 가능

       rear로 들어와서 front로 뺄 수도 있고 다시 rear로 뺄 수도 있다.

       순차적으로 넣다가 우선순위를 넣고싶은 것을 넣을 수 있다.

   - JAVA의 API - java.util

     자료구조는 한번 만들어서 여러 목적에 사용할 수 있는 범용적인 것이다.

     자바는 객체지향적이라 미리 만들어서 재활용해서 사용할 수 있도록 Collection API를 제공한다.

     Collection

     - List(순차 자료구조 성질)

       index로 데이터를 관리

       데이터를 구분할 수 있는 수단이 있으므로 중복데이터가 들어갈 수 있다.

       크기가 가변적(메모리를 재구성- 편하지만 배열보다 성능이 낮다.)

       순서가 있다.

       조회 시 저장 순서와 관계없이 나오면 순서가 없다고 생각한다.

       - Stack
       - LinkedList
         - LinkedList
         - Queue
         - Deck
       - ArrayList(배열과는 다름) - 차례차례 관리하고싶지만 크기를 가변적으로 하고싶을 때

     - Set

       index도 없고 key도 없기 때문에 원소 자체로 집합을 관리한다.

       데이터를 집어넣을때 이 원소가 존재하는지 아닌지 확인해보고 집어넣는다.

       집합의 개념이기 때문에 원소들이 서로 달라야 한다.

       원소의 중복을 허용하지 않는다.

       순서라는 개념이 없다.

       map의 key를 관리할 때 사용하기도 한다.

     - Map

       데이터의 관리를 key로 한다.

       데이터를 구분할 수 있는 수단이 있으므로 중복데이터가 들어갈 수 있다.

       key로 데이터를 찾기 때문에 순서 개념이 없다.

       key(데이터를 찾기위한) 와 값으로 데이터를 관리

       key는 중복되면 안된다. 중복시 덮어쓰기가 된다.

2. 비선형 자료구조

   - 줄을 세울 수 없는 자료구조

     1:多, 多:多

     **비선형 자료구조**

     - 트리 → 1 : 多 에 특화되어있다.

       A			B

       1	→	多

       1	←	1

       계층구조(상위, 하위 구조 성립)

       ![tree structure 이미지 검색결과](https://www.cdn.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png)

       Root Node : 1

       current node : (현재 노드가 1일 때) 1

       current node 의 자식 노드 : 2, 3

       노드끼리의 연결 선 : 간선

       leaf node(가장 끝에 있는 노드들 = 단말노드) = 8,9,10,11,13,14

       자손 노드 : 아래의 모든 노드

       조상 노드 : 위의 모든 노드

       형제 노드 : 같은 부모 노드를 가진 노드들

       차수 : 한 노드에서 자식 노드로 가는(뻗는)'간선'의 숫자

       트리의 차수 : 모든 차수 중 최대값

       Depth(높이) : Root Node에서 Leaf Node까지의 간선의 숫자 중 최대값

       - 실제로 트리를 사용할 때 자식 노드에 대한 제한이 없으면 쓰기가 힘들다.

         - 이진트리 = 차수가 2인트리 = 모든 노드가 자식을 최대 2개까지만 가지는 트리

           - 편향 이진트리 = 방향이 한쪽으로만 가는 이진트리

           - 꽉찬 이진 트리

             - 1차원 배열로 index를 1부터 채워서 사용한다.

           - 순서가 없기 때문에 검색을 위한 방법이 많아 기준이 필요하다.

             - 간선따라 탐색하고 없으면 위로 돌아와서 탐색을 한다.(DFS)

               돌아갈 위치에 대한 데이터가 필요하기 때문에 자료구조가 필요하다.(stack)

               재귀함수로 구현을 많이한다(간접적으로 stack을 사용하는 개념).

               - 이것도 여러가지 방법이 있다.(부모먼저? 아이먼저?)
               - 전위 순회 A-B-C
               - 중위 순회 B-A-C
               - 후위 순회 B-C-A

             - 높이에 따라서 탐색을 한다.(BFS)

               자식에 대한 정보를 불러와서 나중에 처리하게 해야하므로 자료구조가 필요하다.(queue)

             - etc...

     - 그래프 → 多 : 多 에 특화되어있다.

       망형(Network)을 표현하는데 많이 쓴다. (상위 하위가 존재할 수 없다.)

       root보다 vertex(정점)이라는 개념을 사용한다.

       간선(Edge)

       ![img](https://static.packt-cdn.com/products/9781788833738/graphics/4595f8e3-543b-4acc-8886-6e6ae4efb7c9.png)

       트리는 1 : 多 로 제한하고 상 하위를 나눈 그래프의 일종이라고 볼 수 있다.

       ex) 한 점에서 다른 점으로 갈 수 있는 경로들, 사람들 끼리의 관계

       - 그래프 표현법

         1. 인접 행렬

            2차원 배열로 정점 인접관리(얘랑 누구랑 관계가 있다.)

            | 관계의 주체들 | A        | B                               | C                                                            |
            | ------------- | -------- | ------------------------------- | ------------------------------------------------------------ |
            | A             | 0(false) | true(관계가 있다고만 표시할 때) | 10(가중치 - 관계도 있고 그에 대한 정보도 필요할 때 가중치 설정) |
            | B             |          | 0(false)                        |                                                              |
            | C             |          |                                 | 0(false)                                                     |

            - 유향그래프(단방향)

              |      | A    | B    | C    |
              | ---- | ---- | ---- | ---- |
              | A    | f    | t    | 10   |
              | B    |      | f    | t    |
              | C    |      |      | f    |

            - 무향그래프(양방향)

              |      | A    | B    | C    |
              | ---- | ---- | ---- | ---- |
              | A    | f    | t    | 10   |
              | B    | t    | f    | t    |
              | C    | 10   | t    | f    |

              

         2. 인접 리스트

            연결 리스트로 관리

            ![1570090469576](C:\Users\방씨\AppData\Roaming\Typora\typora-user-images\1570090469576.png)

         3. 간선 리스트

            | A B 5  |
            | ------ |
            | A C 10 |
            | B C 15 |
            | B D 10 |

            간선에 대한 정보만 주어진다.

       - 탐색법

         시작점이 주어진다.

         연결되었는지 확인 - 없으면 다른 연결된 노드에 들어가 연결 되었는지 확인 - 없으면 또 거기에 연결된 노드에 들어가 연결 되었는지 확인 - ....... (=DFS(트리에서만 쓰는 개념 아님))

         



# 알고리즘

문제를 해결하기 위한 방법들 = 알고리즘의 유형

#### 알고리즘 효율성

- 시간 복잡도 : 소요 시간에 대한 기준
- 공간 복잡도 : 메모리 사용량에 대한 기준
- 우선도는 경우에 따라 다르긴 하지만 시간 복잡도가 더 우선되긴 한다.

### 1. 완전탐색

####  = 브루트포스(컴퓨터의 처리능력을 이용해서 전부 시도를 해보겠다.)

항상 생각해보고 효율을 보고 결정하자.

특별히 효율적인 알고리즘을 생각하지 못할 때.

가장 범용적이지만 불필요한 과정도 모두 수행하기 때문에 성능상 치명적 단점이 될 수 있음

해가 있다고 했을 때 모두 탐색하므로 해를 못찾는 경우는 없다.

EX) 로봇 탐색을 할 때 모든 배열 요소를 다 확인해봄

EX) 1, 2, 3, 4 숫자 주어지고 원하는 숫자를 구하라 하면 모두 확인해보아야 함

#### 순열(Permutation) 만드는 문제(백준 순열 문제 풀어보면 좋다. n과m시리즈)

- 서로 다른 N개의 수 중에 r개를 뽑아 순서대로 나열 : n**P**r

  { 1, 2, 3 } 3**P**3

  상태 공간 트리(실제로 전부 타고 들어 갔다면)

  먼저 재귀함수 깊이나 횟수를 확인해 시간복잡도를 확인하고 중복을 체크한다.

  1

  - 2 - 3
  - 3 - 2

  2

  - 1 - 3
  - 3 - 1

  3

  - 1 - 2
  - 2 - 1

  3 * 2 * 1 = 3!

- 보통 재귀적으로 많이 푼다.

- selected [f,f,f]

  input [1,2,3]

  num [1열 선택된 수, 2열 선택된 수, 3열 선택된 수]

  ```java
  np(c){
      if(c==r){
          sysout(num 배열); return;
      }
      // 현재열 가능한 수(앞쪽 열까지 선택되지 않은 수) 세워봄
      // 모든 수에 대해서 가능한 수인지 확인하여 세워보기
      for(int i=0; i<3; i++){
          if(!selected[i]){
              selected[i] = true;
              num[c] = input[i];
              np(c+1);
              selected[i] = false;
          }
      }
  }
  ```

#### 방정식의 해 구하기

x + y + z = 15

0	0	1

0	0	2

0	0	3

​	........



### 2. 그리디( =Greedy = 탐욕기법)

문제에 적용하기는 쉽지 않다. 최적화에 대한 문제에만 적용할 수 있다.

전체 집합 중 가장 먼저 처리하면 최적인 것을 먼저 처리하고 그 후 집합에서 최적인 것을 먼저 처리하는것을 반복.

ex)

- 최소동전 교환

  2000원을 최소의 동전으로 교환하자.

  100원 50원 10원

  그리디는 뒤를 돌아보면 안된다. 이게 최선이다 라는 보장이 있어야 함

  | 100원     | 50원     | 10원 |
  | --------- | -------- | ---- |
  | 50원 2개  | 10원 5개 |      |
  | 10원 10개 |          |      |

  위의 방식은 가장 비싼 동전이 다른 동전들을 커버해줄 수 있기 때문에 다음 방식이 사용 가능하다.

  가장 비싼 동전을 먼저 교환해준다.

  아래의 방법은 가장 비싼 동전이 나머지 동전을 커버할 수 없기 때문에 위의 방식을 쓸 수 없다.

  8원을 거슬러 줘라

  | 5원     | 4원     | 1원  |
  | ------- | ------- | ---- |
  | 1원 5개 | 1원 4개 |      |
  |         |         |      |

  위 방식으로 하면 5원 1개 1원 3개 총 4개가 되지만 진짜 답은 4원 2개이다.

#### 정올 그리디 - 회의실 배정

- 내 생각 : 소요시간이 짧은 순으로 정렬
- 옳은 생각 : 입력을 가장 빨리 끝나는 회의 순으로 정렬 후 중복 배제하면서 선택

### 3. 백 트래킹

미로를 통과 할 때 최근에 갈림길로 돌아간다.

진행을 하면서 막히면 다시 돌아와서 다른 진행을 해본다.

가지치기 형식으로 분기를 하지만 조건에 따라서 뒤쪽 내용을 생략할 수 있게 하는게 백 트래킹

이 조건으로 자를 수 있는 가지가 초반이면 초반일 수록 더 좋은 조건이다.

ex) 부분 집합의 합

5, 6, 10, 11, 16 이용해서 21을 구해봐라

**완전 탐색 방식** - 모든 부분 집합을 생성해서 합이 21이 되는 것만 고른다. 2\*2*2\*2\*2

완전 탐색에서 시작해서불필요한 부분을 배제하는 형식으로 사용하기도 한다.

백 트래킹

- 5 선택
  - 6 선택
    - 10 선택(21완성 - 뒤의 진행 버림)
    - 10 버림(21 미완성)
      - 11 선택
        - 16선택
        - 16버림
      - 11 버림
        - 16 선택
        - 16 버림
  - 6 버림
- 5 버림

#### N Queen

4x4

1. 한 행이나 한 열에는 퀸을 놓을 수 없다.
2. 처음 놓는 퀸이 다음 퀸들에게 영향을 주기 때문에 처음이 어디가 좋은지 확인할 수 없다.

해당 행 첫열 ~ 마지막열 Q 시도

다음 행 Q 놓고 8방 탐색(이미 행마다 하나씩이기 때문에 행은 체크안해도됨)

1차원 배열에 queen의 인덱스만 넣어줘도 확인할 수 있다.(행 확인은 할 필요 없고, 열 확인은 인덱스로 확인, 대각선 확인은 )

|      |      |      |      |
| ---- | ---- | ---- | ---- |
|      |      |      |      |
|      |      |      |      |
|      |      |      |      |

#### 단지번호붙이기 - 문제은행

아직 단지로 연결되지 않은 아파트를 찾아서 그 아파트의 인접행렬을 체크하는 방식으로 이미 단지가 설정된 경우 혹은 아파트가 없는 경우 백 트래킹으로 돌아간다.

첫 단지지정이 안된 아파트를 찾고 다른 인접아파트를 찾는데 DFS, BFS를 활용하겠다.

사방 탐색을 하고 인접 아파트를 찾으면 아예 그곳으로 넘어가서 다시 사방탐색을 한다. 탐색을 하는데 탐색을 하는 순서가 정해진 게 아니므로 DFS를 써도 된다. 근처 순서를 매겨야되면 BFS로 하자.

DFS가 어디까지 이어질지 모르는 경우이기 때문에 일반화시킨 재귀함수를 사용해서 탐색을 한다.

DFS, BFS(= 가중치 없는 그래프 최단거리)

| 0    | 1    | 1    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 1    | 0    | 1    | 0    | 1    |
| 1    | 1    | 1    | 0    | 1    | 0    | 1    |
| 0    | 0    | 0    | 0    | 1    | 1    | 1    |
| 0    | 1    | 0    | 0    | 0    | 0    | 0    |
| 0    | 1    | 1    | 1    | 1    | 1    | 0    |
| 0    | 1    | 1    | 1    | 0    | 0    | 0    |

단지번호 : 2

### 4. 분할 정복(Devide and Conquer)

큰 문제를 작은 문제로 쪼개는 것을 반복하고 더 이상 쪼갤 수 없는 작은 문제가 되면 그것이 문제를 풀기 위한 것이 된다.

단위를 쪼개고 쪼개고 닮은 꼴을 찾아야 한다. 가장 작은 단위를 푸는 방식을 한단계 더 큰 단위, 더 큰단위, 더 큰단위에 적용할 수 있는 방식

ex) 원소를 4개를 정렬하라

2 / 5 / 6 / 1		반으로 나눔

2 / 5		 6 / 1

2		5		6		1

​	2 / 5			1 / 6

​			1/2/5/6

ex) quick sort, merge sort

#### 분할정복 - 색종이만들기



### 5. 



자세한 개념은 인터넷강의로 다시 살펴보고 문제를 풀어보자.